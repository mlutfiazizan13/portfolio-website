{
    "status": 200,
    "message": "List of Technology",
    "data": [
        {
            "id": 1,
            "name": "Yorunify°",
            "slug": "yorunify",
            "teaserDesc": "Yorunify° is a Spotify top track and artist generator.",
            "desc": "Yorunify° is a web-based application built with React that lets you see your Spotify top 10 tracks or artists across different time ranges — last month, last 6 months, and all time.",
            "image": "/assets/project/yorunify/yorunify-main.png",
            "date": "2024-2-11",
            "type": "Portofolio",
            "client": "Personal Portofolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/yorunify",
            "technology": [
                {
                    "id": 1,
                    "name": "React",
                    "image": "/assets/images/react.png"
                },
                {
                    "id": 2,
                    "name": "Javascript",
                    "image": "/assets/images/js.png"
                }
            ],
            "images": [
                {
                    "id": 1,
                    "name": "yotunify-1",
                    "image": "/assets/project/yorunify/yorunify-1.png"
                },
                {
                    "id": 2,
                    "name": "yotunify-2",
                    "image": "/assets/project/yorunify/yorunify-2.png"
                },
                {
                    "id": 3,
                    "name": "yotunify-3",
                    "image": "/assets/project/yorunify/yorunify-3.png"
                }
            ],
            "content": [
                {
                    "type": "paragraph",
                    "text": "Yorunify° is a web-based application built with React that lets you see your Spotify top 10 tracks or artists across different time ranges — last month, last 6 months, and all time. It uses the Spotify Web API with OAuth 2.0 authentication."
                },
                {
                    "type": "heading",
                    "text": "Features"
                },
                {
                    "type": "list",
                    "items": [
                        "View top 10 tracks for last month, last 6 months, and all time",
                        "View top 10 artists across the same time ranges",
                        "OAuth 2.0 authentication via Spotify",
                        "Clean, minimal UI focused on the music data"
                    ]
                }
            ]
        },
        {
            "id": 2,
            "name": "Lutfi's Personal Website",
            "slug": "lutfis-personal-website",
            "teaserDesc": "The personal portfolio site you are currently viewing, built with React and Tailwind CSS.",
            "desc": "This is the personal portfolio website you are currently viewing. Built with React and Tailwind CSS, it serves as a central place to showcase my projects, skills, and professional experience.",
            "image": "/assets/project/personal-website/main.png",
            "date": "2023-11-14",
            "type": "Portofolio",
            "client": "Personal Portofolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/portofolio-website",
            "technology": [
                {
                    "id": 1,
                    "name": "React",
                    "image": "/assets/images/react.png"
                },
                {
                    "id": 2,
                    "name": "Javascript",
                    "image": "/assets/images/js.png"
                }
            ],
            "images": [
                {
                    "id": 1,
                    "name": "personal-website-1",
                    "image": "/assets/project/personal-website/1.png"
                },
                {
                    "id": 2,
                    "name": "personal-website-2",
                    "image": "/assets/project/personal-website/2.png"
                }
            ],
            "content": [
                {
                    "type": "paragraph",
                    "text": "This is the personal portfolio site you are currently viewing. It was built to be a clean, minimal showcase of my work and background. The site uses React Router for page navigation and Tailwind CSS for all styling, with project data sourced from local JSON files."
                },
                {
                    "type": "heading",
                    "text": "Stack"
                },
                {
                    "type": "list",
                    "items": [
                        "React 18 with functional components and hooks",
                        "React Router v6 for client-side navigation",
                        "Tailwind CSS for utility-first styling",
                        "Axios for fetching from local JSON datasources",
                        "FontAwesome for icons"
                    ]
                }
            ]
        },
        {
            "id": 3,
            "name": "Resume Parser & Summarizer",
            "slug": "resume-parser-summarizer",
            "teaserDesc": "A backend tool that parses PDF resumes and generates intelligent summaries using a local LLM via Ollama.",
            "desc": "A resume analysis tool built with Quarkus that parses PDF resumes and generates intelligent summaries using Large Language Models via Ollama — fully on-premise, no external APIs.",
            "image": "/assets/project/resume-parser-summarizer/main.png",
            "date": "2025-05-29",
            "type": "Portofolio",
            "client": "Personal Portofolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/simple-resume-parser",
            "technology": [
                {
                    "id": 1,
                    "name": "Quarkus"
                },
                {
                    "id": 2,
                    "name": "Ollama"
                }
            ],
            "images": [],
            "content": [
                {
                    "type": "paragraph",
                    "text": "This application is a resume analysis tool built with Quarkus, designed to parse PDF resumes and generate intelligent summaries using Large Language Models (LLMs) via Ollama. It automates the extraction of key information — personal details, education, work experience, and skills — from uploaded PDF files."
                },
                {
                    "type": "heading",
                    "text": "How It Works"
                },
                {
                    "type": "paragraph",
                    "text": "The application exposes a REST endpoint that accepts PDF file uploads. Once received, it uses Apache PDFBox to extract the raw text, then forwards it to a locally running Ollama instance with a structured prompt to produce a clean, human-readable summary."
                },
                {
                    "type": "ordered-list",
                    "items": [
                        "User uploads a PDF resume via the REST API",
                        "Quarkus processes the file and extracts raw text using Apache PDFBox",
                        "The extracted text is sent to Ollama with a structured summarization prompt",
                        "The LLM returns a structured summary with key candidate information",
                        "The summary is returned to the caller as JSON"
                    ]
                },
                {
                    "type": "heading",
                    "text": "Key Features"
                },
                {
                    "type": "list",
                    "items": [
                        "PDF parsing with Apache PDFBox",
                        "LLM-powered summarization via Ollama",
                        "RESTful API built on the Quarkus framework",
                        "Extracts personal details, education, work experience, and skills",
                        "Runs fully on-premise — no data sent to external APIs"
                    ]
                },
                {
                    "type": "callout",
                    "variant": "info",
                    "title": "Privacy First",
                    "text": "By using Ollama locally, all resume processing happens on your own machine. No candidate data is ever sent to external services."
                },
                {
                    "type": "heading",
                    "text": "Getting Started"
                },
                {
                    "type": "paragraph",
                    "text": "Make sure you have Ollama installed and a model pulled locally before running the application."
                },
                {
                    "type": "code",
                    "language": "bash",
                    "text": "# Pull a model\nollama pull llama3\n\n# Start the Quarkus app in dev mode\n./mvnw quarkus:dev"
                }
            ]
        },
        {
            "id": 4,
            "name": "API Monetization Gateway",
            "slug": "api-monetization-gateway",
            "teaserDesc": "A production-ready API gateway in Go that handles authentication, rate limiting, quota enforcement, usage metering, and Stripe billing for multi-tenant SaaS platforms.",
            "desc": "A full-featured API monetization gateway built with Go and Chi that sits between clients and upstream APIs — managing API keys, enforcing rate limits and monthly quotas, recording usage metrics, and integrating Stripe billing, all with a clean layered architecture.",
            "image": "/assets/project/resume-parser-summarizer/main.png",
            "date": "2026-02-24",
            "type": "Portfolio",
            "client": "Personal Portfolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/api-monitization-gateway",
            "technology": [
                {
                    "id": 1,
                    "name": "Go"
                },
                {
                    "id": 2,
                    "name": "Chi"
                },
                {
                    "id": 3,
                    "name": "PostgreSQL"
                },
                {
                    "id": 4,
                    "name": "Redis"
                },
                {
                    "id": 5,
                    "name": "Stripe"
                },
                {
                    "id": 6,
                    "name": "Docker"
                },
                {
                    "id": 7,
                    "name": "Swagger"
                }
            ],
            "images": [],
            "content": [
                {
                    "type": "paragraph",
                    "text": "API Monetization Gateway is a production-ready reverse proxy and billing layer built with Go and the Chi router. It sits between your clients and any upstream API, transparently handling authentication, rate limiting, quota enforcement, usage metering, and Stripe-powered billing — everything a SaaS product needs to turn an API into a paid service."
                },
                {
                    "type": "heading",
                    "text": "The Problem It Solves"
                },
                {
                    "type": "paragraph",
                    "text": "Building a monetized API from scratch requires solving a cluster of cross-cutting concerns: secure key issuance, per-plan rate limits, monthly quotas, usage analytics, and billing. This gateway packages all of that into a single deployable service, so upstream APIs stay simple and focused on business logic."
                },
                {
                    "type": "heading",
                    "text": "Architecture"
                },
                {
                    "type": "paragraph",
                    "text": "The project follows a clean layered architecture — handlers parse HTTP requests and delegate to services, services contain business logic and call repositories, and repositories own all raw SQL. Redis handles caching and real-time rate limiting; PostgreSQL stores tenants, API keys, and usage history."
                },
                {
                    "type": "ordered-list",
                    "items": [
                        "Incoming request hits the gateway endpoint with an API key",
                        "APIKey Auth Middleware validates the key (Redis cache → PostgreSQL fallback)",
                        "Rate Limit Middleware checks a Redis sliding window (per-second and per-minute)",
                        "Quota Middleware checks the tenant's monthly request count against their plan",
                        "Request is reverse-proxied to the upstream URL with path rewriting",
                        "Usage event is dispatched asynchronously to a buffered channel worker for recording"
                    ]
                },
                {
                    "type": "heading",
                    "text": "Key Features"
                },
                {
                    "type": "list",
                    "items": [
                        "API key creation, revocation, and rotation with SHA-256 hashing",
                        "JWT authentication for the developer portal (24-hour tokens)",
                        "Redis sliding-window rate limiting — per-second and per-minute, plan-aware",
                        "Monthly quota enforcement with Redis counters and PostgreSQL fallback",
                        "Async usage metering via buffered channel (2,000 capacity) and batch worker",
                        "Stripe billing integration — subscriptions, invoices, and hosted billing portal",
                        "Reverse proxy with transparent path forwarding to any upstream URL",
                        "Swagger / OpenAPI documentation auto-generated at /swagger/",
                        "Multi-stage Docker build with Docker Compose for local development"
                    ]
                },
                {
                    "type": "heading",
                    "text": "Subscription Plans"
                },
                {
                    "type": "list",
                    "items": [
                        "Free — 1 req/sec, 1,000 requests/month",
                        "Starter — $29/month, 10 req/sec, 100,000 requests/month",
                        "Pro — $99/month, 100 req/sec, 1,000,000 requests/month"
                    ]
                },
                {
                    "type": "callout",
                    "variant": "info",
                    "title": "Fail-Open by Design",
                    "text": "Rate limiting and quota checks are intentionally fail-open. If Redis becomes temporarily unavailable, requests are allowed through rather than dropping legitimate traffic. Availability is prioritised over strict enforcement during infrastructure hiccups."
                },
                {
                    "type": "heading",
                    "text": "API Overview"
                },
                {
                    "type": "paragraph",
                    "text": "The gateway exposes three groups of routes: public auth endpoints (/auth/register, /auth/login), a JWT-protected developer portal for key and billing management, and the proxied gateway endpoint (/gateway/*) that accepts an API key via Bearer token, X-API-Key header, or query parameter."
                },
                {
                    "type": "code",
                    "language": "bash",
                    "text": "# Register and get a JWT\ncurl -X POST http://localhost:8080/auth/register \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"name\":\"Acme\",\"email\":\"dev@acme.com\",\"password\":\"secret\"}'\n\n# Create an API key\ncurl -X POST http://localhost:8080/keys \\\n  -H 'Authorization: Bearer <jwt>' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"name\":\"production\"}'\n\n# Call the upstream through the gateway\ncurl http://localhost:8080/gateway/v1/data \\\n  -H 'Authorization: Bearer gw_xxxxxxxxxxxxxxxx'"
                },
                {
                    "type": "heading",
                    "text": "Getting Started"
                },
                {
                    "type": "paragraph",
                    "text": "Clone the repository, copy the environment file, spin up the infrastructure with Docker Compose, run the database migrations, and start the server with hot reload."
                },
                {
                    "type": "code",
                    "language": "bash",
                    "text": "# Start PostgreSQL and Redis\nmake docker-up\n\n# Copy environment config\ncp .env.example .env\n\n# Run database migrations\nmake migrate-up\n\n# Start the server with hot reload\nmake dev"
                }
            ]
        }
    ]
}