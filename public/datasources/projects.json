{
    "status": 200,
    "message": "List of Technology",
    "data": [
        {
            "id": 1,
            "name": "Yorunify°",
            "slug": "yorunify",
            "teaserDesc": "Yorunify° is a Spotify top track and artist generator.",
            "desc": "Yorunify° is a web-based application built with React that lets you see your Spotify top 10 tracks or artists across different time ranges — last month, last 6 months, and all time.",
            "image": "/assets/project/yorunify/yorunify-main.png",
            "date": "2024-2-11",
            "type": "Portofolio",
            "client": "Personal Portofolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/yorunify",
            "technology": [
                {
                    "id": 1,
                    "name": "React",
                    "image": "/assets/images/react.png"
                },
                {
                    "id": 2,
                    "name": "Javascript",
                    "image": "/assets/images/js.png"
                }
            ],
            "images": [
                {
                    "id": 1,
                    "name": "yotunify-1",
                    "image": "/assets/project/yorunify/yorunify-1.png"
                },
                {
                    "id": 2,
                    "name": "yotunify-2",
                    "image": "/assets/project/yorunify/yorunify-2.png"
                },
                {
                    "id": 3,
                    "name": "yotunify-3",
                    "image": "/assets/project/yorunify/yorunify-3.png"
                }
            ],
            "content": [
                {
                    "type": "paragraph",
                    "text": "Yorunify° is a web-based application built with React that lets you see your Spotify top 10 tracks or artists across different time ranges — last month, last 6 months, and all time. It uses the Spotify Web API with OAuth 2.0 authentication."
                },
                {
                    "type": "heading",
                    "text": "Features"
                },
                {
                    "type": "list",
                    "items": [
                        "View top 10 tracks for last month, last 6 months, and all time",
                        "View top 10 artists across the same time ranges",
                        "OAuth 2.0 authentication via Spotify",
                        "Clean, minimal UI focused on the music data"
                    ]
                }
            ]
        },
        {
            "id": 2,
            "name": "Lutfi's Personal Website",
            "slug": "lutfis-personal-website",
            "teaserDesc": "The personal portfolio site you are currently viewing, built with React and Tailwind CSS.",
            "desc": "This is the personal portfolio website you are currently viewing. Built with React and Tailwind CSS, it serves as a central place to showcase my projects, skills, and professional experience.",
            "image": "/assets/project/personal-website/main.png",
            "date": "2023-11-14",
            "type": "Portofolio",
            "client": "Personal Portofolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/portofolio-website",
            "technology": [
                {
                    "id": 1,
                    "name": "React",
                    "image": "/assets/images/react.png"
                },
                {
                    "id": 2,
                    "name": "Javascript",
                    "image": "/assets/images/js.png"
                }
            ],
            "images": [
                {
                    "id": 1,
                    "name": "personal-website-1",
                    "image": "/assets/project/personal-website/1.png"
                },
                {
                    "id": 2,
                    "name": "personal-website-2",
                    "image": "/assets/project/personal-website/2.png"
                }
            ],
            "content": [
                {
                    "type": "paragraph",
                    "text": "This is the personal portfolio site you are currently viewing. It was built to be a clean, minimal showcase of my work and background. The site uses React Router for page navigation and Tailwind CSS for all styling, with project data sourced from local JSON files."
                },
                {
                    "type": "heading",
                    "text": "Stack"
                },
                {
                    "type": "list",
                    "items": [
                        "React 18 with functional components and hooks",
                        "React Router v6 for client-side navigation",
                        "Tailwind CSS for utility-first styling",
                        "Axios for fetching from local JSON datasources",
                        "FontAwesome for icons"
                    ]
                }
            ]
        },
        {
            "id": 3,
            "name": "Resume Parser & Summarizer",
            "slug": "resume-parser-summarizer",
            "teaserDesc": "A backend tool that parses PDF resumes and generates intelligent summaries using a local LLM via Ollama.",
            "desc": "A resume analysis tool built with Quarkus that parses PDF resumes and generates intelligent summaries using Large Language Models via Ollama — fully on-premise, no external APIs.",
            "image": "/assets/project/resume-parser-summarizer/main.png",
            "date": "2025-05-29",
            "type": "Portofolio",
            "client": "Personal Portofolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/simple-resume-parser",
            "technology": [
                {
                    "id": 1,
                    "name": "Quarkus"
                },
                {
                    "id": 2,
                    "name": "Ollama"
                }
            ],
            "images": [],
            "content": [
                {
                    "type": "paragraph",
                    "text": "This application is a resume analysis tool built with Quarkus, designed to parse PDF resumes and generate intelligent summaries using Large Language Models (LLMs) via Ollama. It automates the extraction of key information — personal details, education, work experience, and skills — from uploaded PDF files."
                },
                {
                    "type": "heading",
                    "text": "How It Works"
                },
                {
                    "type": "paragraph",
                    "text": "The application exposes a REST endpoint that accepts PDF file uploads. Once received, it uses Apache PDFBox to extract the raw text, then forwards it to a locally running Ollama instance with a structured prompt to produce a clean, human-readable summary."
                },
                {
                    "type": "ordered-list",
                    "items": [
                        "User uploads a PDF resume via the REST API",
                        "Quarkus processes the file and extracts raw text using Apache PDFBox",
                        "The extracted text is sent to Ollama with a structured summarization prompt",
                        "The LLM returns a structured summary with key candidate information",
                        "The summary is returned to the caller as JSON"
                    ]
                },
                {
                    "type": "heading",
                    "text": "Key Features"
                },
                {
                    "type": "list",
                    "items": [
                        "PDF parsing with Apache PDFBox",
                        "LLM-powered summarization via Ollama",
                        "RESTful API built on the Quarkus framework",
                        "Extracts personal details, education, work experience, and skills",
                        "Runs fully on-premise — no data sent to external APIs"
                    ]
                },
                {
                    "type": "callout",
                    "variant": "info",
                    "title": "Privacy First",
                    "text": "By using Ollama locally, all resume processing happens on your own machine. No candidate data is ever sent to external services."
                },
                {
                    "type": "heading",
                    "text": "Getting Started"
                },
                {
                    "type": "paragraph",
                    "text": "Make sure you have Ollama installed and a model pulled locally before running the application."
                },
                {
                    "type": "code",
                    "language": "bash",
                    "text": "# Pull a model\nollama pull llama3\n\n# Start the Quarkus app in dev mode\n./mvnw quarkus:dev"
                }
            ]
        },
        {
            "id": 4,
            "name": "API Monetization Gateway",
            "slug": "api-monetization-gateway",
            "teaserDesc": "A production-ready API gateway in Go that handles authentication, rate limiting, quota enforcement, usage metering, and Stripe billing for multi-tenant SaaS platforms.",
            "desc": "A full-featured API monetization gateway built with Go and Chi that sits between clients and upstream APIs — managing API keys, enforcing rate limits and monthly quotas, recording usage metrics, and integrating Stripe billing, all with a clean layered architecture.",
            "image": "/assets/project/resume-parser-summarizer/main.png",
            "date": "2026-02-24",
            "type": "Portfolio",
            "client": "Personal Portfolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/api-monitization-gateway",
            "technology": [
                {
                    "id": 1,
                    "name": "Go"
                },
                {
                    "id": 2,
                    "name": "Chi"
                },
                {
                    "id": 3,
                    "name": "PostgreSQL"
                },
                {
                    "id": 4,
                    "name": "Redis"
                },
                {
                    "id": 5,
                    "name": "Stripe"
                },
                {
                    "id": 6,
                    "name": "Docker"
                },
                {
                    "id": 7,
                    "name": "Swagger"
                }
            ],
            "images": [],
            "content": [
                {
                    "type": "paragraph",
                    "text": "API Monetization Gateway is a production-ready reverse proxy and billing layer built with Go and the Chi router. It sits between your clients and any upstream API, transparently handling authentication, rate limiting, quota enforcement, usage metering, and Stripe-powered billing — everything a SaaS product needs to turn an API into a paid service."
                },
                {
                    "type": "heading",
                    "text": "The Problem It Solves"
                },
                {
                    "type": "paragraph",
                    "text": "Building a monetized API from scratch requires solving a cluster of cross-cutting concerns: secure key issuance, per-plan rate limits, monthly quotas, usage analytics, and billing. This gateway packages all of that into a single deployable service, so upstream APIs stay simple and focused on business logic."
                },
                {
                    "type": "heading",
                    "text": "Architecture"
                },
                {
                    "type": "paragraph",
                    "text": "The project follows a clean layered architecture — handlers parse HTTP requests and delegate to services, services contain business logic and call repositories, and repositories own all raw SQL. Redis handles caching and real-time rate limiting; PostgreSQL stores tenants, API keys, and usage history."
                },
                {
                    "type": "ordered-list",
                    "items": [
                        "Incoming request hits the gateway endpoint with an API key",
                        "APIKey Auth Middleware validates the key (Redis cache → PostgreSQL fallback)",
                        "Rate Limit Middleware checks a Redis sliding window (per-second and per-minute)",
                        "Quota Middleware checks the tenant's monthly request count against their plan",
                        "Request is reverse-proxied to the upstream URL with path rewriting",
                        "Usage event is dispatched asynchronously to a buffered channel worker for recording"
                    ]
                },
                {
                    "type": "heading",
                    "text": "Key Features"
                },
                {
                    "type": "list",
                    "items": [
                        "API key creation, revocation, and rotation with SHA-256 hashing",
                        "JWT authentication for the developer portal (24-hour tokens)",
                        "Redis sliding-window rate limiting — per-second and per-minute, plan-aware",
                        "Monthly quota enforcement with Redis counters and PostgreSQL fallback",
                        "Async usage metering via buffered channel (2,000 capacity) and batch worker",
                        "Stripe billing integration — subscriptions, invoices, and hosted billing portal",
                        "Reverse proxy with transparent path forwarding to any upstream URL",
                        "Swagger / OpenAPI documentation auto-generated at /swagger/",
                        "Multi-stage Docker build with Docker Compose for local development"
                    ]
                },
                {
                    "type": "heading",
                    "text": "Subscription Plans"
                },
                {
                    "type": "list",
                    "items": [
                        "Free — 1 req/sec, 1,000 requests/month",
                        "Starter — $29/month, 10 req/sec, 100,000 requests/month",
                        "Pro — $99/month, 100 req/sec, 1,000,000 requests/month"
                    ]
                },
                {
                    "type": "callout",
                    "variant": "info",
                    "title": "Fail-Open by Design",
                    "text": "Rate limiting and quota checks are intentionally fail-open. If Redis becomes temporarily unavailable, requests are allowed through rather than dropping legitimate traffic. Availability is prioritised over strict enforcement during infrastructure hiccups."
                },
                {
                    "type": "heading",
                    "text": "API Overview"
                },
                {
                    "type": "paragraph",
                    "text": "The gateway exposes three groups of routes: public auth endpoints (/auth/register, /auth/login), a JWT-protected developer portal for key and billing management, and the proxied gateway endpoint (/gateway/*) that accepts an API key via Bearer token, X-API-Key header, or query parameter."
                },
                {
                    "type": "code",
                    "language": "bash",
                    "text": "# Register and get a JWT\ncurl -X POST http://localhost:8080/auth/register \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"name\":\"Acme\",\"email\":\"dev@acme.com\",\"password\":\"secret\"}'\n\n# Create an API key\ncurl -X POST http://localhost:8080/keys \\\n  -H 'Authorization: Bearer <jwt>' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"name\":\"production\"}'\n\n# Call the upstream through the gateway\ncurl http://localhost:8080/gateway/v1/data \\\n  -H 'Authorization: Bearer gw_xxxxxxxxxxxxxxxx'"
                },
                {
                    "type": "heading",
                    "text": "Getting Started"
                },
                {
                    "type": "paragraph",
                    "text": "Clone the repository, copy the environment file, spin up the infrastructure with Docker Compose, run the database migrations, and start the server with hot reload."
                },
                {
                    "type": "code",
                    "language": "bash",
                    "text": "# Start PostgreSQL and Redis\nmake docker-up\n\n# Copy environment config\ncp .env.example .env\n\n# Run database migrations\nmake migrate-up\n\n# Start the server with hot reload\nmake dev"
                }
            ]
        },
        {
            "id": 5,
            "name": "URL Shortener",
            "slug": "url-shortener",
            "teaserDesc": "A full-stack URL shortener built with Node.js and React that converts long URLs into shareable short links with click analytics, expiration control, and JWT-based user authentication.",
            "desc": "A full-stack URL shortener service built with Express.js, PostgreSQL, and React — featuring user authentication, short link generation, optional expiration dates, and per-link click analytics, all wrapped in a clean Tailwind UI.",
            "image": "/assets/project/url-shortener/main.png",
            "date": "2025-11-16",
            "type": "Portfolio",
            "client": "Personal Portfolio",
            "repositoryLink": "https://github.com/mlutfiazizan13/url-shortener",
            "technology": [
                {
                    "id": 1,
                    "name": "Node.js"
                },
                {
                    "id": 2,
                    "name": "Express.js"
                },
                {
                    "id": 3,
                    "name": "PostgreSQL"
                },
                {
                    "id": 4,
                    "name": "Sequelize"
                },
                {
                    "id": 5,
                    "name": "React"
                },
                {
                    "id": 6,
                    "name": "Vite"
                },
                {
                    "id": 7,
                    "name": "Tailwind CSS"
                },
                {
                    "id": 8,
                    "name": "JWT"
                }
            ],
            "images": [],
            "content": [
                {
                    "type": "paragraph",
                    "text": "URL Shortener is a full-stack web application that turns long, unwieldy URLs into clean, shareable short links. Built with Express.js on the backend and React on the frontend, it gives registered users a personal dashboard to create, manage, and track every link they shorten — including click counts, referrers, and optional expiration dates."
                },
                {
                    "type": "heading",
                    "text": "The Problem It Solves"
                },
                {
                    "type": "paragraph",
                    "text": "Long URLs break in emails, look unprofessional in social posts, and are impossible to remember. This service lets users generate concise short codes in one click, set an expiry when the link is time-sensitive, and review analytics to understand how their links are being used — all without relying on a third-party service."
                },
                {
                    "type": "heading",
                    "text": "Architecture"
                },
                {
                    "type": "paragraph",
                    "text": "The project is split into two independently runnable apps. The backend follows an MVC pattern — routes delegate to controllers, controllers contain business logic, and Sequelize models own the database layer. The frontend is a React SPA that communicates with the API over fetch, persisting the JWT in localStorage for a seamless session between page loads."
                },
                {
                    "type": "ordered-list",
                    "items": [
                        "User registers or logs in — the server returns a signed JWT (1-day expiry)",
                        "Authenticated user submits a long URL (and optional expiration date) to POST /url/shorten",
                        "The backend generates a random 6-character short code, persists it with Sequelize, and returns the short URL",
                        "Anyone visiting the short link hits GET /:shortCode — the server resolves the code, records the click (IP, referrer, user agent), and issues a 302 redirect",
                        "The owner can view per-link stats or delete the link from their dashboard"
                    ]
                },
                {
                    "type": "heading",
                    "text": "Key Features"
                },
                {
                    "type": "list",
                    "items": [
                        "User registration and login with bcrypt password hashing and JWT authentication",
                        "One-click URL shortening with random 6-character short codes",
                        "Optional expiration dates — short links can be set to expire automatically",
                        "Click tracking per redirect: timestamp, IP address, HTTP referrer, and user agent",
                        "Per-link statistics dashboard showing total clicks and click history",
                        "Delete links at any time from the authenticated dashboard",
                        "Copy-to-clipboard button for instant sharing",
                        "React SPA frontend with Tailwind CSS styling and lucide-react icons",
                        "Sequelize ORM with PostgreSQL — auto-sync on startup for frictionless local dev"
                    ]
                },
                {
                    "type": "heading",
                    "text": "Database Schema"
                },
                {
                    "type": "paragraph",
                    "text": "Three Sequelize models cover the full data model. Users own URLs (one-to-many), and each URL accumulates Clicks every time the short link is followed. All primary keys are UUIDs for safe distributed use."
                },
                {
                    "type": "list",
                    "items": [
                        "User — id (UUID), email (unique), passwordHash, timestamps",
                        "Url — id (UUID), originalUrl, shortCode (unique, max 10 chars), expiresAt (nullable), userId FK",
                        "Click — id (UUID), ipAddress, referrer, userAgent, clickedAt, urlId FK"
                    ]
                },
                {
                    "type": "heading",
                    "text": "API Overview"
                },
                {
                    "type": "paragraph",
                    "text": "The API exposes public auth and redirect endpoints alongside JWT-protected routes for URL management. All protected endpoints expect an Authorization: Bearer <token> header."
                },
                {
                    "type": "code",
                    "language": "bash",
                    "text": "# Register a new account\ncurl -X POST http://localhost:3000/register \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"email\":\"user@example.com\",\"password\":\"secret\"}'\n\n# Log in and get a JWT\ncurl -X POST http://localhost:3000/login \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"email\":\"user@example.com\",\"password\":\"secret\"}'\n\n# Shorten a URL (optional expiry)\ncurl -X POST http://localhost:3000/url/shorten \\\n  -H 'Authorization: Bearer <token>' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"originalUrl\":\"https://example.com/very/long/path\",\"expiresAt\":\"2026-12-31T23:59:59Z\"}'\n\n# Follow a short link (public)\ncurl -L http://localhost:3000/abc123\n\n# View click stats\ncurl http://localhost:3000/url/stats/abc123 \\\n  -H 'Authorization: Bearer <token>'"
                },
                {
                    "type": "heading",
                    "text": "Getting Started"
                },
                {
                    "type": "paragraph",
                    "text": "Clone the repository, configure environment variables for both apps, and start the backend and frontend dev servers separately."
                },
                {
                    "type": "code",
                    "language": "bash",
                    "text": "# Install backend dependencies and configure env\ncd backend\nnpm install\ncp .env.example .env   # fill in DB_HOST, DB_NAME, DB_USER, DB_PASS, JWT_SECRET\n\n# Start the API server (default: http://localhost:3000)\nnpm start\n\n# In a separate terminal — install and start the frontend\ncd frontend\nnpm install\nnpm run dev   # Vite dev server at http://localhost:5173"
                },
                {
                    "type": "callout",
                    "variant": "info",
                    "title": "API Documentation",
                    "text": "A full Postman collection with example requests and responses is published at https://documenter.getpostman.com/view/14331304/2sB3WwpH83 — import it to explore every endpoint without writing a single curl command."
                }
            ]
        }
    ]
}